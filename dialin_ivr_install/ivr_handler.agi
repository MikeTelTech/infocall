#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import os
import logging
import traceback
import sqlite3
import time
import subprocess  # For ffmpeg
import requests    # For Flask API call
from datetime import datetime, timezone  # For timestamping final file

# --- Early Debug Output ---
sys.stderr.write("DEBUG_AGI_LOAD: ivr_handler.agi started.\n")
sys.stderr.flush()

# --- Configuration ---
LOG_FILE = '/var/log/asterisk/infocall_agi.log'
TEMP_RECORDING_DIR = '/var/www/html/infocall/uploads/temp'
FINAL_UPLOAD_DIR = '/var/www/html/infocall/uploads'
STATE_DB_PATH = '/var/lib/asterisk/call_state.db'
FFMPEG_PATH = '/usr/local/bin/ffmpeg'
FLASK_API_URL = 'http://127.0.0.1:5000/api/ivr_schedule_trigger'

PROMPT_MAIN_MENU = "custom/infocall-ivr-menu"
PROMPT_RECORD = "custom/infocall-record-prompt"
PROMPT_RECORD_FAIL = "custom/infocall-record-fail"
PROMPT_NO_RECORDING = "custom/infocall-no-recording"
PROMPT_SAVE_SUCCESS = "custom/infocall-save-success"
PROMPT_SAVE_FAIL = "custom/infocall-save-fail"
PROMPT_GOODBYE = "custom/infocall-goodbye"
PROMPT_INVALID_OPTION = "pbx-invalid"
SOUND_BEEP = "beep"

# --- Logging Setup ---
try:
    logging.basicConfig(
        filename=LOG_FILE,
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    log = logging.getLogger('ivr_handler_integrated')
    log.info("--- ivr_handler.agi script started ---")
except Exception as log_setup_err:
    sys.stderr.write(f"CRITICAL_ERROR: Failed to configure logging: {log_setup_err}\n")
    sys.stderr.flush()
    log = logging.getLogger('ivr_handler_integrated_fallback')
    log.addHandler(logging.StreamHandler(sys.stderr))
    log.setLevel(logging.INFO)
    log.error("CRITICAL_ERROR: File logging failed, using stderr fallback.", exc_info=True)

# --- AGI Library Import ---
try:
    log.info("DEBUG_STEP: Attempting to import AGI library...")
    from asterisk.agi import AGI
    from asterisk.agi import AGIAppError, AGISIGHUPHangup
    log.info("DEBUG_STEP: AGI library imported successfully.")
except ImportError:
    log.critical("CRITICAL_ERROR: python-asterisk-agi library not found. Please install it.", exc_info=True)
    sys.stderr.write("CRITICAL_ERROR: python-asterisk-agi library not found. Please install it.\n")
    sys.stderr.flush()
    sys.exit(1)
except Exception as e:
    log.critical(f"CRITICAL_ERROR: Unexpected error importing AGI library: {e}", exc_info=True)
    sys.stderr.write(f"CRITICAL_ERROR: Unexpected error importing AGI library: {e}\n")
    sys.stderr.flush()
    sys.exit(1)

# --- Database Connector & Config Import ---
try:
    log.info("DEBUG_STEP: Attempting to import DB config and MySQL connector...")
    import mysql.connector
    APP_ROOT = '/var/www/html/infocall'
    if APP_ROOT not in sys.path:
        log.info(f"DEBUG_STEP: Adding {APP_ROOT} to sys.path")
        sys.path.insert(0, APP_ROOT)
    from config import DB_HOST, DB_USER, DB_PASSWORD, DB_NAME
    log.info("DEBUG_STEP: DB config and MySQL connector imported successfully.")
except ImportError as e:
    log.critical(f"CRITICAL_ERROR: Failed to import DB config or mysql.connector: {e}", exc_info=True)
    sys.stderr.write(f"CRITICAL_ERROR: Failed to import DB config or mysql.connector: {e}\n")
    sys.stderr.flush()
    sys.exit(1)
except Exception as e:
    log.critical(f"CRITICAL_ERROR: General error importing dependencies: {e}", exc_info=True)
    sys.stderr.write(f"CRITICAL_ERROR: General error importing dependencies: {e}\n")
    sys.stderr.flush()
    sys.exit(1)

# --- State Database Setup ---
def ensure_state_db_exists():
    log.info("DEBUG_STATE_DB: Entering ensure_state_db_exists()")
    conn = None
    try:
        db_dir = os.path.dirname(STATE_DB_PATH)
        log.info(f"DEBUG_STATE_DB: Checking/creating directory: {db_dir}")
        if not os.path.exists(db_dir):
            try:
                os.makedirs(db_dir, exist_ok=True)
                log.info(f"DEBUG_STATE_DB: Created directory {db_dir}")
            except OSError as dir_err:
                log.error(f"CRITICAL_ERROR: Failed to create directory for state DB {db_dir}: {dir_err}", exc_info=True)
                return False
        log.info(f"DEBUG_STATE_DB: Attempting to connect to SQLite DB: {STATE_DB_PATH}")
        conn = sqlite3.connect(STATE_DB_PATH, timeout=2.0)
        log.info("DEBUG_STATE_DB: SQLite connection successful.")
        cursor = conn.cursor()
        log.info("DEBUG_STATE_DB: Executing CREATE TABLE IF NOT EXISTS.")
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS call_state (
            call_id TEXT PRIMARY KEY,
            recording_id TEXT,
            temp_file_path TEXT,
            auth_user_id TEXT,
            timestamp INTEGER
        )
        ''')
        conn.commit()
        log.info(f"DEBUG_STATE_DB: State database table ensured at {STATE_DB_PATH}")
        return True
    except Exception as e:
        log.error(f"CRITICAL_ERROR: Failed to initialize state database: {e}", exc_info=True)
        return False
    finally:
        if conn:
            log.info("DEBUG_STATE_DB: Closing SQLite connection.")
            conn.close()
        log.info("DEBUG_STATE_DB: Exiting ensure_state_db_exists()")

def ensure_final_dir_exists():
    log.info(f"DEBUG_HELPER: Ensuring final upload directory exists: {FINAL_UPLOAD_DIR}")
    if not os.path.exists(FINAL_UPLOAD_DIR):
        try:
            os.makedirs(FINAL_UPLOAD_DIR, exist_ok=True)
            log.info(f"DEBUG_HELPER: Created final upload directory: {FINAL_UPLOAD_DIR}")
        except OSError as e:
            log.error(f"CRITICAL_ERROR: Failed to create final upload directory {FINAL_UPLOAD_DIR}: {e}", exc_info=True)
            raise

# --- Main IVR Handler Class ---
class IVRHandler:
    def __init__(self):
        log.info("DEBUG_INIT: Entering IVRHandler.__init__()")
        try:
            log.info("DEBUG_INIT: Initializing AGI() object...")
            self.agi = AGI()
            log.info("DEBUG_INIT: AGI() object initialized.")
            self.call_id = self.agi.env.get('agi_uniqueid', f'unknown_{int(time.time())}')
            self.caller_id_num = self.agi.env.get('agi_callerid', 'unknown')
            log.info(f"DEBUG_INIT: Call ID: {self.call_id}, Caller: {self.caller_id_num}")
            self.recording_id = None
            self.temp_file_path = None
            self.auth_user_id = "0"
            log.info("DEBUG_INIT: Initial state variables set.")
        except Exception as agi_init_err:
            log.critical(f"CRITICAL_ERROR: Failed during AGI object/env var setup in __init__: {agi_init_err}", exc_info=True)
            raise
        log.info("DEBUG_INIT: Calling ensure_state_db_exists()...")
        db_ok = ensure_state_db_exists()
        log.info(f"DEBUG_INIT: ensure_state_db_exists() returned: {db_ok}")
        if db_ok:
            log.info("DEBUG_INIT: Calling load_state()...")
            self.load_state()
            log.info("DEBUG_INIT: load_state() finished.")
        else:
            log.critical("CRITICAL_ERROR: STATE DATABASE FAILED TO INITIALIZE. IVR may not function correctly.")
        log.info("DEBUG_INIT: Processing arguments...")
        try:
            log.info(f"DEBUG_INIT: Arguments received: {sys.argv}")
            if len(sys.argv) > 1 and sys.argv[1].isdigit():
                arg_user_id = sys.argv[1]
                log.info(f"DEBUG_INIT: Found argument user ID: {arg_user_id}")
                if self.auth_user_id != arg_user_id:
                    log.info(f"DEBUG_INIT: Received authenticated user ID argument: {arg_user_id} (overriding stored/default: {self.auth_user_id})")
                    self.auth_user_id = arg_user_id
                    log.info("DEBUG_INIT: Calling save_state() after processing argument...")
                    self.save_state()
                    log.info("DEBUG_INIT: save_state() finished.")
                else:
                    log.info(f"DEBUG_INIT: Argument user ID {arg_user_id} matches stored/default {self.auth_user_id}. No state save needed here.")
            else:
                log.warning("DEBUG_INIT: No valid authenticated user ID received as argument, using stored or default '0'.")
        except Exception as e:
            log.error(f"DEBUG_INIT: Error processing arguments: {e}", exc_info=True)
        log.info("DEBUG_INIT: Exiting IVRHandler.__init__()")

    def _db_connect(self):
        log.debug("DEBUG_DB_CONNECT: Attempting SQLite connection...")
        try:
            conn = sqlite3.connect(STATE_DB_PATH, timeout=1.0)
            log.debug(f"DEBUG_DB_CONNECT: SQLite connection successful to {STATE_DB_PATH}")
            return conn
        except Exception as e:
            log.error(f"DEBUG_DB_CONNECT: Failed to connect to state DB {STATE_DB_PATH}: {e}", exc_info=True)
            return None

    def load_state(self):
        log.info(f"DEBUG_LOAD_STATE: Loading state for call_id: {self.call_id}")
        conn = self._db_connect()
        if not conn:
            log.error("DEBUG_LOAD_STATE: Failed to connect to DB, cannot load state.")
            return
        try:
            cursor = conn.cursor()
            log.info("DEBUG_LOAD_STATE: Executing SELECT query...")
            cursor.execute("SELECT recording_id, temp_file_path, auth_user_id FROM call_state WHERE call_id = ?", (self.call_id,))
            row = cursor.fetchone()
            log.info(f"DEBUG_LOAD_STATE: Fetchone result: {row}")
            if row:
                self.recording_id = row[0] if row[0] else None
                self.temp_file_path = row[1] if row[1] else None
                self.auth_user_id = row[2] if row[2] else "0"
                log.info(f"DEBUG_LOAD_STATE: Loaded state for call {self.call_id}: rec_id={self.recording_id}, path={self.temp_file_path}, user={self.auth_user_id}")
                if self.temp_file_path and not os.path.exists(self.temp_file_path):
                    log.warning(f"DEBUG_LOAD_STATE: Temp file {self.temp_file_path} referenced in state no longer exists. Clearing state.")
                    self.recording_id = None
                    self.temp_file_path = None
            else:
                log.info(f"DEBUG_LOAD_STATE: No previous state found for call {self.call_id}")
        except Exception as e:
            log.error(f"DEBUG_LOAD_STATE: Error loading state from database: {e}", exc_info=True)
        finally:
            if conn:
                log.debug("DEBUG_LOAD_STATE: Closing DB connection.")
                conn.close()
        log.info("DEBUG_LOAD_STATE: Exiting load_state.")

    def save_state(self):
        log.info(f"DEBUG_SAVE_STATE: Saving state for call_id: {self.call_id}")
        conn = self._db_connect()
        if not conn:
            log.error("DEBUG_SAVE_STATE: Failed to connect to DB, cannot save state.")
            return
        try:
            cursor = conn.cursor()
            log.info("DEBUG_SAVE_STATE: Executing INSERT OR REPLACE query...")
            log.info(f"DEBUG_SAVE_STATE: Values - call_id={self.call_id}, rec_id={self.recording_id}, path={self.temp_file_path}, user={self.auth_user_id}")
            cursor.execute('''
            INSERT OR REPLACE INTO call_state
            (call_id, recording_id, temp_file_path, auth_user_id, timestamp)
            VALUES (?, ?, ?, ?, ?)
            ''', (
                self.call_id,
                self.recording_id,
                self.temp_file_path,
                self.auth_user_id,
                int(time.time())
            ))
            conn.commit()
            log.info(f"DEBUG_SAVE_STATE: State saved successfully.")
        except Exception as e:
            log.error(f"DEBUG_SAVE_STATE: Error saving state to database: {e}", exc_info=True)
            if conn:
                try:
                    log.warning("DEBUG_SAVE_STATE: Rolling back transaction due to error.")
                    conn.rollback()
                except Exception as rb_err:
                    log.error(f"DEBUG_SAVE_STATE: Error during rollback: {rb_err}", exc_info=True)
        finally:
            if conn:
                log.debug("DEBUG_SAVE_STATE: Closing DB connection.")
                conn.close()
        log.info("DEBUG_SAVE_STATE: Exiting save_state.")

    def clear_state(self, delete_temp_file=True):
        log.info(f"DEBUG_CLEAR_STATE: Entering clear_state for call {self.call_id} (delete_file={delete_temp_file})")
        old_path = self.temp_file_path
        old_rec_id = self.recording_id
        log.info(f"DEBUG_CLEAR_STATE: State before clearing - rec_id={old_rec_id}, path={old_path}")
        self.recording_id = None
        self.temp_file_path = None
        log.info("DEBUG_CLEAR_STATE: Internal state variables cleared.")
        conn = self._db_connect()
        if not conn:
            log.error("DEBUG_CLEAR_STATE: Cannot connect to DB to delete state record.")
        else:
            try:
                cursor = conn.cursor()
                log.info(f"DEBUG_CLEAR_STATE: Executing DELETE from call_state for call_id: {self.call_id}")
                cursor.execute("DELETE FROM call_state WHERE call_id = ?", (self.call_id,))
                conn.commit()
                log.info(f"DEBUG_CLEAR_STATE: DB record deleted successfully (Rows affected: {cursor.rowcount}).")
            except Exception as e:
                log.error(f"DEBUG_CLEAR_STATE: Error deleting state from database: {e}", exc_info=True)
                if conn: conn.rollback()
            finally:
                if conn: conn.close()
        if delete_temp_file:
            if old_path and os.path.exists(old_path):
                log.info(f"DEBUG_CLEAR_STATE: Attempting to delete temp file: {old_path}")
                try:
                    os.remove(old_path)
                    log.info(f"DEBUG_CLEAR_STATE: Deleted temp file: {old_path}")
                except OSError as e:
                    log.error(f"DEBUG_CLEAR_STATE: Error deleting temp file {old_path}: {e}")
            elif old_path:
                log.info(f"DEBUG_CLEAR_STATE: Temp file path was set ({old_path}), but file does not exist. No deletion needed.")
            else:
                log.info("DEBUG_CLEAR_STATE: No temp file path was set. No deletion needed.")
        else:
            log.info("DEBUG_CLEAR_STATE: File deletion skipped (delete_temp_file=False).")
        log.info("DEBUG_CLEAR_STATE: Exiting clear_state.")

    def stream_file_interruptible(self, filepath, escape_digits='1234*'):
        log.debug(f"Playing {filepath} interruptible by {escape_digits}")
        try:
            filepath_no_ext = os.path.splitext(filepath)[0]
            log.info(f"DEBUG_AGI_CMD: Stripping extensions for playback: {filepath} -> {filepath_no_ext}")
            log.info(f"DEBUG_AGI_CMD: Calling agi.stream_file('{filepath_no_ext}', escape_digits='{escape_digits}')")
            result = self.agi.stream_file(filepath_no_ext, escape_digits=escape_digits)
            log.info(f"DEBUG_AGI_CMD: agi.stream_file result: {result}")
            digit = None
            if isinstance(result, dict):
                result_code = result.get('result', 0)
                log.debug(f"stream_file returned dict, result code: {result_code}")
            elif isinstance(result, int):
                result_code = result
                log.debug(f"stream_file returned int: {result_code}")
            else:
                result_code = 0
                log.warning(f"stream_file returned unexpected type: {type(result)}")
            if result_code > 0:
                try:
                    digit = chr(result_code)
                    log.info(f"Playback interrupted by digit: {digit} (ASCII: {result_code})")
                except ValueError:
                    log.error(f"Failed to convert result code {result_code} to character.")
                    return 0
            else:
                log.debug("Playback not interrupted.")
            return digit if digit else 0
        except Exception as e:
            log.error(f"Error in stream_file_interruptible for {filepath}: {e}", exc_info=True)
            return 0

    def record_announcement(self):
        log.info("DEBUG_RECORD: Entering record_announcement")
        log.info("DEBUG_RECORD: Clearing previous state before recording (delete_temp_file=True).")
        self.clear_state(delete_temp_file=True)
        recording_id_to_use = self.call_id
        log.info(f"DEBUG_RECORD: Using recording ID (uniqueid): {recording_id_to_use}")
        temp_file_base = os.path.join(TEMP_RECORDING_DIR, f"{recording_id_to_use}")
        expected_recorded_path = f"{temp_file_base}.wav"
        log.info(f"DEBUG_RECORD: Base path for record_file: {temp_file_base}")
        log.info(f"DEBUG_RECORD: Expected path after recording: {expected_recorded_path}")
        try:
            log.info(f"DEBUG_RECORD: Ensuring temp directory exists: {TEMP_RECORDING_DIR}")
            os.makedirs(TEMP_RECORDING_DIR, exist_ok=True)
            log.info(f"DEBUG_RECORD: Directory check/creation complete for: {TEMP_RECORDING_DIR}")
        except OSError as e:
            log.error(f"CRITICAL_ERROR: Cannot create/access temp directory {TEMP_RECORDING_DIR}: {e}", exc_info=True)
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_RECORD_FAIL} due to directory error.")
                self.agi.stream_file(PROMPT_RECORD_FAIL)
            except Exception as stream_err:
                log.error(f"Failed to play PROMPT_RECORD_FAIL after directory error: {stream_err}", exc_info=True)
            return False
        try:
            log.info("DEBUG_RECORD: Playing pre-recording prompts...")
            log.info(f"DEBUG_AGI_CMD: Playing {SOUND_BEEP}")
            # self.agi.stream_file(SOUND_BEEP)
            log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_RECORD}")
            self.agi.stream_file(PROMPT_RECORD)
            log.info(f"DEBUG_AGI_CMD: Playing {SOUND_BEEP}")
            self.agi.stream_file(SOUND_BEEP)
            log.info("DEBUG_RECORD: Prompts finished.")
        except Exception as prompt_err:
            log.error(f"DEBUG_RECORD: Error playing prompts: {prompt_err}", exc_info=True)
            return False
        recording_successful = False
        try:
            log.info(f"DEBUG_AGI_CMD: Calling agi.record_file with path: {temp_file_base}, format: wav, escape: #*, timeout: 120000")
            result = self.agi.record_file(
                temp_file_base,
                'wav',
                '#*',
                120000,
                0,
                beep=False
            )
            log.info(f"DEBUG_AGI_CMD: RECORD FILE result raw: {result}")
            log.info(f"DEBUG_RECORD: Checking expected recorded path: {expected_recorded_path}")
            file_exists = os.path.exists(expected_recorded_path)
            file_size = -1
            if file_exists:
                try:
                    file_size = os.path.getsize(expected_recorded_path)
                except OSError as size_err:
                    log.error(f"DEBUG_RECORD: Error getting size for {expected_recorded_path}: {size_err}")
                    file_exists = False
            log.info(f"DEBUG_RECORD: Expected file check results - Exists: {file_exists}, Size: {file_size}")
            if file_exists and file_size > 44:
                recording_successful = True
                self.temp_file_path = expected_recorded_path
                log.info(f"DEBUG_RECORD: Recording check PASSED. Using temp_file_path: {self.temp_file_path}")
                self.recording_id = recording_id_to_use
                log.info(f"DEBUG_RECORD: Stored ID: {self.recording_id}")
            else:
                log.warning(f"DEBUG_RECORD: Recording check FAILED for expected path: {expected_recorded_path}. Exists={file_exists}, Size={file_size}")
                if file_exists:
                    try:
                        log.warning(f"DEBUG_RECORD: Attempting to remove potentially failed/empty file: {expected_recorded_path}")
                        os.remove(expected_recorded_path)
                        log.info(f"DEBUG_RECORD: Cleaned up potentially failed/empty file: {expected_recorded_path}")
                    except OSError as rem_err:
                        log.error(f"DEBUG_RECORD: Error removing file {expected_recorded_path}: {rem_err}")
                self.temp_file_path = None
                self.recording_id = None
        except Exception as e:
            log.error(f"CRITICAL_ERROR: Error during agi.record_file call: {e}", exc_info=True)
            recording_successful = False
            try:
                path_to_check = expected_recorded_path
                log.warning(f"DEBUG_RECORD: Attempting cleanup after record_file exception for path: {path_to_check}")
                if os.path.exists(path_to_check):
                    os.remove(path_to_check)
                    log.info(f"DEBUG_RECORD: Cleaned up file {path_to_check} after exception.")
            except Exception as cleanup_err:
                log.error(f"DEBUG_RECORD: Error during cleanup after record_file exception: {cleanup_err}")
            self.temp_file_path = None
            self.recording_id = None
        if recording_successful:
            log.info(f"DEBUG_RECORD: Recording success. Attempting to save state with path: {self.temp_file_path}")
            self.save_state()
            log.info("DEBUG_RECORD: Exiting record_announcement (Success)")
            return True
        else:
            log.warning("DEBUG_RECORD: Recording failed (or exception occurred), playing failure prompt and clearing state.")
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_RECORD_FAIL}")
                self.agi.stream_file(PROMPT_RECORD_FAIL)
            except Exception as stream_err:
                log.error(f"Failed to play PROMPT_RECORD_FAIL: {stream_err}", exc_info=True)
            self.clear_state()
            log.warning("DEBUG_RECORD: Exiting record_announcement (Failure)")
            return False

    def playback_recording(self):
        log.info("DEBUG_PLAYBACK: Entering playback_recording")
        self.load_state()
        if not self.recording_id or not self.temp_file_path:
            log.warning("DEBUG_PLAYBACK: No recording ID/path found in state for playback.")
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_NO_RECORDING}")
                self.agi.stream_file(PROMPT_NO_RECORDING)
            except Exception as e:
                log.error(f"Failed to play PROMPT_NO_RECORDING: {e}", exc_info=True)
            return
        log.info(f"DEBUG_PLAYBACK: Checking existence of: {self.temp_file_path}")
        if not os.path.exists(self.temp_file_path):
            log.error(f"DEBUG_PLAYBACK: State DB references missing file: {self.temp_file_path}. Clearing state.")
            self.clear_state()
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_NO_RECORDING}")
                self.agi.stream_file(PROMPT_NO_RECORDING)
            except Exception as e:
                log.error(f"Failed to play PROMPT_NO_RECORDING: {e}", exc_info=True)
            return
        log.info(f"DEBUG_PLAYBACK: Playing back {self.temp_file_path}")
        try:
            self.stream_file_interruptible(self.temp_file_path, escape_digits='')
            log.info("DEBUG_PLAYBACK: Playback finished successfully.")
        except Exception as e:
            log.error(f"DEBUG_PLAYBACK: Playback failed: {e}", exc_info=True)
            try:
                log.info("DEBUG_PLAYBACK: Playing error notification to user")
                self.agi.stream_file('custom/playback-error')
            except Exception as notify_err:
                log.error(f"DEBUG_PLAYBACK: Failed to play error notification: {notify_err}")

    def save_recording(self):
        log.info("DEBUG_SAVE: Entering save_recording")
        self.load_state()
        save_successful = False
        log.info(f"DEBUG_SAVE: Checking state - rec_id={self.recording_id}, path={self.temp_file_path}")
        if not self.recording_id or not self.temp_file_path:
            log.warning("DEBUG_SAVE: No recording ID/path found in state to save.")
            try:
                self.agi.stream_file(PROMPT_NO_RECORDING)
            except Exception as e:
                log.error(f"Failed to play PROMPT_NO_RECORDING: {e}", exc_info=True)
            return False
        log.info(f"DEBUG_SAVE: Checking existence of temp file: {self.temp_file_path}")
        if not os.path.exists(self.temp_file_path):
            log.error(f"DEBUG_SAVE: State DB references missing file for save: {self.temp_file_path}. Clearing state.")
            self.clear_state()
            try:
                self.agi.stream_file(PROMPT_NO_RECORDING)
            except Exception as e:
                log.error(f"Failed to play PROMPT_NO_RECORDING: {e}", exc_info=True)
            return False
        final_filename_wav = None
        final_file_path = None
        try:
            log.info("DEBUG_SAVE: Ensuring final upload directory exists.")
            ensure_final_dir_exists()
            utc_timestamp_str = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%SZ')
            final_filename_base = f"ivr_rec_{utc_timestamp_str}_{self.auth_user_id}"
            final_filename_wav = f"{final_filename_base}.wav"
            final_file_path = os.path.join(FINAL_UPLOAD_DIR, final_filename_wav)
            log.info(f"DEBUG_SAVE: Target final file path: {final_file_path}")
        except Exception as e:
            log.error(f"DEBUG_SAVE: Error defining final filename: {e}", exc_info=True)
            try:
                self.agi.stream_file(PROMPT_SAVE_FAIL)
            except Exception as e_p:
                log.error(f"Failed to play PROMPT_SAVE_FAIL: {e_p}", exc_info=True)
            return False
        ffmpeg_success = False
        try:
            log.info(f"DEBUG_SAVE: Starting FFMPEG conversion: {self.temp_file_path} -> {final_file_path} (8k, 16b, mono)")
            if not os.path.exists(FFMPEG_PATH):
                log.critical(f"CRITICAL_ERROR: FFmpeg executable not found at {FFMPEG_PATH}")
                raise FileNotFoundError(f"FFmpeg not found at {FFMPEG_PATH}")
            ffmpeg_command = [
                FFMPEG_PATH, '-y',
                '-i', self.temp_file_path,
                '-ar', '8000', '-ac', '1', '-acodec', 'pcm_s16le',
                final_file_path
            ]
            log.debug(f"DEBUG_SAVE: Executing FFmpeg command: {' '.join(ffmpeg_command)}")
            process = subprocess.run(ffmpeg_command, check=False, capture_output=True, text=True, timeout=30)
            log.info(f"DEBUG_SAVE: FFmpeg STDOUT:\n{process.stdout}")
            log.warning(f"DEBUG_SAVE: FFmpeg STDERR:\n{process.stderr}")
            if process.returncode == 0:
                log.info("DEBUG_SAVE: FFmpeg command finished with return code 0.")
                if os.path.exists(final_file_path) and os.path.getsize(final_file_path) > 44:
                    log.info("DEBUG_SAVE: FFmpeg conversion successful and output file verified.")
                    ffmpeg_success = True
                else:
                    log.error(f"DEBUG_SAVE: FFmpeg reported success, but output file is missing or empty: {final_file_path}. Size: {os.path.getsize(final_file_path) if os.path.exists(final_file_path) else 'N/A'}")
            else:
                log.error(f"DEBUG_SAVE: FFmpeg conversion failed! Return code: {process.returncode}")
        except subprocess.TimeoutExpired:
            log.error("DEBUG_SAVE: FFmpeg command timed out.")
        except FileNotFoundError as fnf_err:
            log.error(f"DEBUG_SAVE: FFmpeg error: {fnf_err}")
        except Exception as e:
            log.error(f"DEBUG_SAVE: Unexpected error running ffmpeg: {e}", exc_info=True)
        db_insert_success = False
        new_announcement_id = None
        if ffmpeg_success:
            conn_mysql = None
            cursor_mysql = None
            try:
                log.info(f"DEBUG_SAVE_DB: Connecting to MySQL DB (Host: {DB_HOST}, DB: {DB_NAME}) to insert: {final_filename_wav}")
                conn_mysql = mysql.connector.connect(
                    host=DB_HOST, user=DB_USER, password=DB_PASSWORD, database=DB_NAME,
                    connection_timeout=5
                )
                log.info("DEBUG_SAVE_DB: MySQL connection successful.")
                cursor_mysql = conn_mysql.cursor()
                insert_query = "INSERT INTO announcements (filename) VALUES (%s)"
                log.info(f"DEBUG_SAVE_DB: Executing query: {insert_query} with params: ('{final_filename_wav}',)")
                cursor_mysql.execute(insert_query, (final_filename_wav,))
                new_announcement_id = cursor_mysql.lastrowid
                log.info(f"DEBUG_SAVE_DB: Query executed. Last row ID: {new_announcement_id}")
                conn_mysql.commit()
                log.info("DEBUG_SAVE_DB: Transaction committed.")
                if new_announcement_id:
                    log.info(f"DEBUG_SAVE_DB: Inserted announcement into MySQL DB. New ID: {new_announcement_id}")
                    db_insert_success = True
                else:
                    log.error("DEBUG_SAVE_DB: MySQL insert reported success but did not return a new row ID.")
                    try: conn_mysql.rollback()
                    except: pass
            except mysql.connector.Error as db_err:
                log.error(f"DEBUG_SAVE_DB: MySQL Database error during announcement save: {db_err}", exc_info=True)
                if conn_mysql:
                    try: conn_mysql.rollback()
                    except: pass
            except Exception as e:
                log.error(f"DEBUG_SAVE_DB: Unexpected error during MySQL DB operation: {e}", exc_info=True)
                if conn_mysql:
                    try: conn_mysql.rollback()
                    except: pass
            finally:
                if cursor_mysql:
                    try: cursor_mysql.close()
                    except: pass
                if conn_mysql and conn_mysql.is_connected():
                    log.info("DEBUG_SAVE_DB: Closing MySQL connection.")
                    conn_mysql.close()
            if not db_insert_success and os.path.exists(final_file_path):
                log.warning("DEBUG_SAVE: DB insert failed after ffmpeg success. Cleaning up final file.")
                try:
                    os.remove(final_file_path)
                    log.info(f"DEBUG_SAVE: Cleaned up final file: {final_file_path}")
                except OSError as e:
                    log.error(f"DEBUG_SAVE: Failed to cleanup final file {final_file_path}: {e}")
        api_call_attempted = False
        api_call_success = False
        if db_insert_success and new_announcement_id:
            api_call_attempted = True
            try:
                log.info(f"DEBUG_SAVE_API: Triggering Flask API endpoint: {FLASK_API_URL}")
                api_payload = {
                    'announcement_id': new_announcement_id,
                    'user_id': int(self.auth_user_id)
                }
                log.info(f"DEBUG_SAVE_API: Payload: {api_payload}")
                response = requests.post(FLASK_API_URL, json=api_payload, timeout=10)
                log.info(f"DEBUG_SAVE_API: Response status code: {response.status_code}")
                log.info(f"DEBUG_SAVE_API: Response text: {response.text[:500]}...")
                response.raise_for_status()
                api_response_data = response.json()
                log.info(f"DEBUG_SAVE_API: Parsed JSON response: {api_response_data}")
                if api_response_data.get("success"):
                    log.info(f"DEBUG_SAVE_API: Flask API call successful. Scheduled: {api_response_data.get('scheduled', 'unknown')}")
                    api_call_success = True
                else:
                    log.error(f"DEBUG_SAVE_API: Flask API reported failure: {api_response_data.get('message', 'No message')}")
            except requests.exceptions.RequestException as api_err:
                log.error(f"DEBUG_SAVE_API: Error calling Flask API: {api_err}", exc_info=True)
            except Exception as e:
                log.error(f"DEBUG_SAVE_API: Unexpected error during Flask API call: {e}", exc_info=True)
        if ffmpeg_success and db_insert_success:
            save_successful = True
            log.info("DEBUG_SAVE: Overall save process successful.")
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_SAVE_SUCCESS}")
                self.agi.stream_file(PROMPT_SAVE_SUCCESS)
            except Exception as e:
                log.error(f"Failed to play PROMPT_SAVE_SUCCESS: {e}", exc_info=True)
            temp_file_to_delete_on_save = self.temp_file_path
            log.info("DEBUG_SAVE: Clearing state after successful save.")
            self.clear_state(delete_temp_file=True)
            if temp_file_to_delete_on_save and os.path.exists(temp_file_to_delete_on_save):
                log.info(f"DEBUG_SAVE: Deleting original temp file: {temp_file_to_delete_on_save}")
                try:
                    os.remove(temp_file_to_delete_on_save)
                    log.info("DEBUG_SAVE: Original temp file deleted successfully.")
                except OSError as del_err:
                    log.error(f"DEBUG_SAVE: Failed to delete original temp file {temp_file_to_delete_on_save}: {del_err}")
        else:
            log.error("DEBUG_SAVE: Overall save process FAILED.")
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_SAVE_FAIL}")
                self.agi.stream_file(PROMPT_SAVE_FAIL)
            except Exception as e:
                log.error(f"Failed to play PROMPT_SAVE_FAIL: {e}", exc_info=True)
            log.info("DEBUG_SAVE: State NOT cleared, allowing retry.")
        log.info(f"DEBUG_SAVE: Exiting save_recording. Result: {save_successful}")
        return save_successful

    def cleanup(self):
        log.info(f"DEBUG_CLEANUP: Running cleanup for call {self.call_id}")
        try:
            log.info("DEBUG_CLEANUP: Calling clear_state(delete_temp_file=True) to remove DB record AND temp file...")
            self.clear_state(delete_temp_file=True)
            try:
                log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_GOODBYE}")
                self.agi.stream_file(PROMPT_GOODBYE)
            except Exception as goodbye_err:
                if isinstance(goodbye_err, AGIAppError) or isinstance(goodbye_err, AGISIGHUPHangup):
                    log.warning(f"DEBUG_CLEANUP: Cannot play goodbye, call likely already hung up ({type(goodbye_err).__name__}).")
                else:
                    log.error(f"DEBUG_CLEANUP: Error playing goodbye prompt: {goodbye_err}", exc_info=True)
            try:
                log.info("DEBUG_HANGUP: Attempting final hangup via agi.hangup()")
                self.agi.hangup()
                log.info("DEBUG_HANGUP: agi.hangup() command executed.")
            except Exception as hangup_err:
                if isinstance(hangup_err, AGIAppError) or isinstance(hangup_err, AGISIGHUPHangup):
                    log.warning(f"DEBUG_HANGUP: Cannot hangup, call likely already hung up ({type(hangup_err).__name__}).")
                else:
                    log.error(f"DEBUG_HANGUP: Error executing agi.hangup(): {hangup_err}", exc_info=True)
            log.info("DEBUG_CLEANUP: IVR Handler finished, cleanup complete.")
        except Exception as e:
            log.critical(f"CRITICAL_ERROR: Unhandled error during cleanup: {e}", exc_info=True)
            try:
                log.warning("DEBUG_HANGUP: Fallback hangup attempt after cleanup error.")
                self.agi.hangup()
            except:
                log.critical("CRITICAL_ERROR: Fallback hangup failed during cleanup exception.")

    def run(self):
        log.info("DEBUG_RUN: Entering main run() method.")
        try:
            log.info("DEBUG_AGI_CMD: Attempting agi.answer()...")
            self.agi.answer()
            log.info("DEBUG_AGI_CMD: agi.answer() successful.")
            log.info(f"DEBUG_RUN: IVR Handler started processing call: UniqueID={self.call_id}, CallerID={self.caller_id_num}")
            max_retries = 3
            invalid_count = 0
            while invalid_count < max_retries:
                log.info(f"DEBUG_RUN: Top of main menu loop (Retry {invalid_count+1}/{max_retries}). Current rec ID: {self.recording_id}")
                digit = None
                try:
                    log.info(f"DEBUG_AGI_CMD: Calling agi.get_data('{PROMPT_MAIN_MENU}', timeout=10000, max_digits=1)...")
                    digit_result = self.agi.get_data(PROMPT_MAIN_MENU, timeout=10000, max_digits=1)
                    log.info(f"DEBUG_AGI_CMD: agi.get_data result: {digit_result} (type: {type(digit_result)})")
                    if isinstance(digit_result, str) and len(digit_result) == 1 and digit_result.isdigit():
                        digit = digit_result
                    elif digit_result is None or digit_result == '':
                        digit = None
                        log.info("DEBUG_RUN: Timeout or empty result waiting for menu digit.")
                    else:
                        log.warning(f"DEBUG_RUN: Unexpected result from get_data: {digit_result}")
                        digit = None
                except Exception as get_data_err:
                    log.error(f"DEBUG_RUN: Error during agi.get_data: {get_data_err}", exc_info=True)
                    digit = None
                log.info(f"DEBUG_RUN: User pressed digit: {digit}")
                if digit is None:
                    log.warning("DEBUG_RUN: No digit received (timeout or error). Exiting loop.")
                    invalid_count += 1
                    break
                invalid_count = 0
                if digit == '1':
                    log.info("DEBUG_RUN: Option 1 selected. Calling record_announcement...")
                    self.record_announcement()
                elif digit == '2':
                    log.info("DEBUG_RUN: Option 2 selected. Calling playback_recording...")
                    self.playback_recording()
                elif digit == '3':
                    log.info("DEBUG_RUN: Option 3 selected. Calling save_recording...")
                    if self.save_recording():
                        log.info("DEBUG_RUN: Save successful, breaking loop.")
                        break
                    else:
                        log.info("DEBUG_RUN: Save failed, continuing loop.")
                elif digit == '4':
                    log.info("DEBUG_RUN: Option 4 selected (Re-record). Calling record_announcement...")
                    self.record_announcement()
                elif digit == '*':
                    log.info("DEBUG_RUN: Option * selected (Exit). Breaking loop.")
                    break
                else:
                    log.warning(f"DEBUG_RUN: Invalid digit pressed: {digit}")
                    try:
                        log.info(f"DEBUG_AGI_CMD: Playing {PROMPT_INVALID_OPTION}")
                        self.agi.stream_file(PROMPT_INVALID_OPTION)
                    except Exception as e:
                        log.error(f"Failed to play PROMPT_INVALID_OPTION: {e}", exc_info=True)
                    invalid_count += 1
                    log.info(f"DEBUG_RUN: Invalid count now: {invalid_count}")
            log.info(f"DEBUG_RUN: Exited main menu loop. Invalid count: {invalid_count}")
            log.info("DEBUG_RUN: Calling cleanup()...")
            self.cleanup()
            log.info("DEBUG_RUN: cleanup() finished.")
        except Exception as e:
            log.critical(f"CRITICAL_ERROR: Unhandled exception in main run loop: {e}", exc_info=True)
            try:
                log.error("DEBUG_RUN: Attempting cleanup after main loop exception...")
                self.cleanup()
                log.error("DEBUG_RUN: Cleanup finished after exception.")
            except Exception as cleanup_err:
                log.critical("CRITICAL_ERROR: Error during cleanup after main loop exception.", exc_info=True)
                try:
                    log.warning("DEBUG_HANGUP: Fallback hangup attempt after cleanup error.")
                    self.agi.hangup()
                except:
                    log.critical("CRITICAL_ERROR: Fallback hangup failed.")

# --- Script Entry Point ---
if __name__ == "__main__":
    log.info("DEBUG_MAIN: Script execution starting in __main__ block.")
    main_handler = None
    try:
        log.info("DEBUG_MAIN: Instantiating IVRHandler...")
        main_handler = IVRHandler()
        log.info("DEBUG_MAIN: IVRHandler instantiated successfully. Calling run()...")
        try:
            main_handler.run()
            log.info("DEBUG_MAIN: IVRHandler.run() completed.")
        except AttributeError as attr_err:
            log.critical(f"CRITICAL_ERROR: Method not found: {attr_err}", exc_info=True)
            sys.stderr.write(f"FATAL_ATTRIBUTE_ERROR: {attr_err}\n")
            sys.stderr.flush()
            sys.exit(1)
    except Exception as e:
        log.critical("CRITICAL_ERROR: Unhandled exception at top level of IVR Handler script", exc_info=True)
        sys.stderr.write(f"FATAL_ERROR_TOP_LEVEL: {e}\n{traceback.format_exc()}\n")
        sys.stderr.flush()
        if main_handler and hasattr(main_handler, 'agi'):
            try:
                log.warning("DEBUG_HANGUP: Fallback hangup attempt after top-level error.")
                main_handler.agi.hangup()
            except:
                log.critical("CRITICAL_ERROR: Fallback hangup failed after top-level error.")
        else:
            try:
                log.warning("DEBUG_HANGUP: Fallback hangup attempt (basic AGI) after top-level error.")
                agi_fallback = AGI()
                agi_fallback.hangup()
            except:
                log.critical("CRITICAL_ERROR: Fallback basic AGI hangup failed.")
        sys.exit(1)
    finally:
        log.info("--- ivr_handler.agi script finished ---")

